#!/usr/bin/env ruby

require 'rubygems'
require 'optparse'
require 'rubigen'
require 'rubigen/scripts/generate'
require File.dirname(__FILE__) + "/../lib/butterfly"

# defines some colors for commando line
PURPLE = "\033[0;35m"
BLUE   = "\033[0;34m"
WHITE  = "\033[0;37m"
RED    = "\033[0;31m"


### Set up generators

# get code generators
generators = Butterfly::CodeGenerators.new

# Add all code generators to the beginning of a list of sources where we look in order.
RubiGen::Base.prepend_sources(generators.sources) 

### Parse options and arguments from command-line

# get default options:
options = Butterfly::DEFAULTS

# default options
class OptionParser
  def on_default(opts)
    self.separator ""

    self.on("-n", "--new", "Create a new Code Generator in .butterfly") do
      opts[:new] = true
    end

    self.on("-q", "--quiet", "Suppress status output") do
      opts[:quiet] = true
    end

    self.on("-g", "--git", "Create an empty git repository") do
      opts[:git] = true
    end

    self.separator ""
    self.define_head "Version #{Butterfly::VERSION}"
    self.define_head "A life-enhancing code generator for everyday use."
    self.define_head ""
  end
end

# parse options (after parsing they are removed from ARGV)
parser = OptionParser.new do |opts|
  opts.banner = "Usage: #{PURPLE}#{File.basename($0)}#{WHITE} [options] #{BLUE}<generator-group>#{WHITE} <generator-type> <project-name>"
  opts.on_default(options)
  opts.separator "#{BLUE}Please choose a generator-group:#{WHITE}"
  opts.separator ""
  generators.names.each do |name|
    opts.separator "    #{BLUE}#{name}#{WHITE}"
  end
end
parser.parse!



# parse arguments:
# first argument is <generator-group>
if ARGV.length == 1
  generator_group = ARGV[0]
  generator_types = generators.types_of(generator_group)
  
  # check if first argument is an existing generator-group
  if generators.names.include?(generator_group)

    # show generator-types
    parser = OptionParser.new do |opts|
      opts.banner = "Usage: #{PURPLE}#{File.basename($0)}#{WHITE} [options] #{PURPLE}#{generator_group}#{WHITE} #{BLUE}<generator-type>#{WHITE} <project-name>"
      opts.on_default(options)
      opts.separator "#{BLUE}Please choose a #{generator_group} generator-type:#{WHITE}"
      opts.separator ""
      generator_types.each do |type|
        opts.separator "    #{BLUE}#{type}#{WHITE}"
      end
    end
    parser.parse!
  else
    raise Butterfly::GeneratorError, "#{RED}generator group '#{generator_group}' does not exist.#{WHITE}" 
  end
end

# second argument is <generator-type>
if ARGV.length == 2
  generator_group = ARGV[0]
  generator_types = generators.types_of(generator_group)
  generator_type = ARGV[1]

  # check if second argument is an existing generator-type
  if generator_types.include?(generator_type)
#    project_name = File.basename(Dir.pwd)
    parser = OptionParser.new do |opts|
      opts.banner = "Usage: #{PURPLE}#{File.basename($0)}#{WHITE} [options] #{PURPLE}#{generator_group}#{WHITE} #{PURPLE}#{generator_type}#{WHITE} #{BLUE}<project-name>#{WHITE}"
      opts.on_default(options)
      opts.separator "#{BLUE}Please enter a project-name!#{WHITE}"
    end
    parser.parse!

  else
    raise Butterfly::GeneratorError, "#{RED}generator type '#{generator_type}' does not exist in generator group '#{generator_group}'.#{WHITE}" 
  end  
end

# show help if generator-group, generator-type and project-name is missing
if ARGV.length != 3
  parser.parse(["-h"])
  exit
end

generator_group = ARGV[0]
generator_type = ARGV[1]
project_name = ARGV[2]

puts generator_group
puts generator_type
puts project_name


#RubiGen::Scripts::Generate.new.run(["baaz"], :generator => 'static')
#RubiGen::Scripts::Generate.new.run(project_name, :generator => generator_type, :backtrace => true)
